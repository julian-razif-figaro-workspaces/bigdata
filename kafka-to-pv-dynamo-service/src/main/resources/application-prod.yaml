spring:
  config:
    activate:
      on-profile: prod

# Kafka Config
kafka-consumer-config:
  bootstrap-servers: ${KAFKA-CONSUMER-CONFIG_BOOTSTRAP-SERVERS}
  client-id: ${KAFKA-CONSUMER-CONFIG_CLIENT-ID}
  group-id: ${KAFKA-CONSUMER-CONFIG_GROUP-ID}
  key-deserializer: ${KAFKA-CONSUMER-CONFIG_KEY-DESERIALIZER}
  value-deserializer: ${KAFKA-CONSUMER-CONFIG_VALUE-DESERIALIZER}
  enable-auto-commit: ${KAFKA-CONSUMER-CONFIG_ENABLE-AUTO-COMMIT}
  auto-offset-reset: ${KAFKA-CONSUMER-CONFIG_AUTO-OFFSET-RESET}
  batch-listener: ${KAFKA-CONSUMER-CONFIG_BATCH-LISTENER}
  auto-startup: ${KAFKA-CONSUMER-CONFIG_AUTO-STARTUP}
  concurrency-level: ${KAFKA-CONSUMER-CONFIG_CONCURRENCY-LEVEL}
  session-timeout-ms: ${KAFKA-CONSUMER-CONFIG_SESSION-TIMEOUT-MS}
  heartbeat-interval-ms: ${KAFKA-CONSUMER-CONFIG_HEARTBEAT-INTERVAL-MS}
  max-poll-interval-ms: ${KAFKA-CONSUMER-CONFIG_MAX-POLL-INTERVAL-MS}
  max-poll-records: ${KAFKA-CONSUMER-CONFIG_MAX-POLL-RECORDS}
  max-partition-fetch-bytes-default: ${KAFKA-CONSUMER-CONFIG_MAX-PARTITION-FETCH-BYTES-DEFAULT}
  max-partition-fetch-bytes-boost-factor: ${KAFKA-CONSUMER-CONFIG_MAX-PARTITION-FETCH-BYTES-BOOSTS-FACTOR}
  poll-timeout-ms: ${KAFKA-CONSUMER-CONFIG_POLL-TIMEOUT-MS}

  # Fetch optimization for throughput
  fetch-min-bytes: ${KAFKA-CONSUMER-CONFIG_FETCH-MIN-BYTES}
  fetch-max-wait-ms: ${KAFKA-CONSUMER-CONFIG_FETCH-MAX-WAIT-MS}

  # Connection pooling and management
  connections-max-idle-ms: ${KAFKA-CONSUMER-CONFIG_CONNECTIONS-MAX-IDLE-MS}
  request-timeout-ms: ${KAFKA-CONSUMER-CONFIG_REQUEST-TIMEOUT-MS}

  # Compression for network optimization
  compression-type: ${KAFKA-CONSUMER-CONFIG_COMPRESSION-TYPE}

  num-of-partitions: ${KAFKA-CONSUMER-CONFIG_NUM-OF-PARTITIONS}
  replication-factor: ${KAFKA-CONSUMER-CONFIG_REPLICATION-FACTOR}
  redis-temp-data-topic: ${KAFKA-CONSUMER-CONFIG_REDIS-TEMP-DATA-TOPIC}

# Dynamo Config
dynamo-config-data:

  # AWS Config
  dynamodb-endpoint: ${DYNAMO-CONFIG-DATA_DYNAMODB-ENDPOINT}
  aws-region: ${DYNAMO-CONFIG-DATA_AWS-REGION}
  aws-accesskey: ${DYNAMO-CONFIG-DATA_AWS-ACCESSKEY}
  aws-secretkey: ${DYNAMO-CONFIG-DATA_AWS-SECRETKEY}

  # Table names
  table-name-session-provider-member: ${DYNAMO-CONFIG-DATA_TABLE-NAME-SESSION-PROVIDER-MEMBER}
  table-name-session-user: ${DYNAMO-CONFIG-DATA_TABLE-NAME-SESSION-USER}
  table-name-persistence-provider-member: ${DYNAMO-CONFIG-DATA_TABLE-NAME-PERSISTENCE-PROVIDER-MEMBER}
  table-name-persistence-user: ${DYNAMO-CONFIG-DATA_TABLE-NAME-PERSISTENCE-USER}

  # Session activity names
  act-session-user-pv: ${DYNAMO-CONFIG-DATA_ACT-SESSION-USER-PV}
  act-session-user: ${DYNAMO-CONFIG-DATA_ACT-SESSION-USER}

  # Connection settings
  connectionTTL: ${DYNAMO-CONFIG-DATA_CONNECTION-TTL}
  connection-timeout: ${DYNAMO-CONFIG-DATA_CONNECTION-TIMEOUT}
  client-execution-timeout: ${DYNAMO-CONFIG-DATA_CLIENT-EXECUTION-TIMEOUT}
  request-timeout: ${DYNAMO-CONFIG-DATA_REQUEST-TIMEOUT}
  socket-timeout: ${DYNAMO-CONFIG-DATA_SOCKET-TIMEOUT}
  max-retry: ${DYNAMO-CONFIG-DATA_MAX-RETRY}
  throttled-retries: ${DYNAMO-CONFIG-DATA_THROTTLED-RETRIES}
  connection-max-idle-millis: ${DYNAMO-CONFIG-DATA_CONNECTION-MAX-IDLE-MILLIS}
  max-connections: ${DYNAMO-CONFIG-DATA_MAX-CONNECTIONES}
  tcp-keep-alive: ${DYNAMO-CONFIG-DATA_TCP-KEEP-ALIVE}

# JVM Configuration for Production
# Apply these JVM options to the application startup command or container environment
# 
# Option 1: ZGC (Recommended for low-latency requirements)
# -XX:+UseZGC
# -XX:ZUncommitDelay=300
# -XX:+ZGenerational
# -Xmx8g
# -Xms4g
# -XX:+UseStringDeduplication
# -XX:+OptimizeStringConcat
# 
# Option 2: G1GC (Recommended for balanced throughput/latency)
# -XX:+UseG1GC
# -XX:MaxGCPauseMillis=200
# -XX:G1HeapRegionSize=16m
# -XX:InitiatingHeapOccupancyPercent=45
# -Xmx8g
# -Xms4g
# -XX:+UseStringDeduplication
# -XX:+OptimizeStringConcat
# 
# Common JVM Options for Both GCs:
# -XX:+HeapDumpOnOutOfMemoryError
# -XX:HeapDumpPath=/var/log/heapdump.hprof
# -XX:+UseCompressedOops
# -XX:+UseCompressedClassPointers
# -XX:+AlwaysPreTouch
# -Djava.security.egd=file:/dev/./urandom
# 
# Virtual Threads Monitoring (Java 21+):
# -Djdk.tracePinnedThreads=full
# 
# For Kubernetes/Docker deployment, add to container specification:
# env:
#   - name: JAVA_TOOL_OPTIONS
#     value: "-XX:+UseZGC -XX:+ZGenerational -Xmx8g -Xms4g"
